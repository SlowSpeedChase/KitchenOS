{
  "name": "YouTube Recipe - Webhook",
  "active": true,
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "recipe",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook-trigger",
      "name": "Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [240, 300],
      "webhookId": "recipe-webhook"
    },
    {
      "parameters": {
        "command": "/tmp/kitchenos/run-recipe.sh '{{$json.body.url}}'"
      },
      "id": "fetch-transcript",
      "name": "Fetch Transcript",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [460, 300]
    },
    {
      "parameters": {
        "jsCode": "// Parse the JSON output from Python script\nconst output = $input.first().json.stdout;\n\n// Handle potential extra output lines (library warnings)\nconst lines = output.trim().split('\\n');\nconst jsonLine = lines[lines.length - 1];\n\ntry {\n  const data = JSON.parse(jsonLine);\n  return [{ json: data }];\n} catch (e) {\n  return [{ json: { error: 'Failed to parse JSON', raw: output } }];\n}"
      },
      "id": "parse-json",
      "name": "Parse JSON",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [680, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "check-success",
              "leftValue": "={{ $json.success }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "true"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-success",
      "name": "Check Success",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [900, 300]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://localhost:11434/api/generate",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"model\": \"mistral:7b\",\n  \"prompt\": \"You are a recipe extraction assistant. Given a YouTube video transcript and description about cooking, extract a structured recipe.\\n\\nRules:\\n- Extract ONLY what is shown/said in the video\\n- When inferring (timing, quantities, temperatures), mark with \\\"(estimated)\\\"\\n- If a field cannot be determined, use null\\n- Set needs_review: true if significant inference was required\\n- List confidence_notes explaining what was inferred vs explicit\\n\\nOutput valid JSON matching this schema:\\n{\\n  \\\"recipe_name\\\": \\\"string\\\",\\n  \\\"description\\\": \\\"string (1-2 sentences)\\\",\\n  \\\"prep_time\\\": \\\"string or null\\\",\\n  \\\"cook_time\\\": \\\"string or null\\\",\\n  \\\"servings\\\": \\\"number or null\\\",\\n  \\\"difficulty\\\": \\\"easy|medium|hard or null\\\",\\n  \\\"cuisine\\\": \\\"string or null\\\",\\n  \\\"protein\\\": \\\"string or null\\\",\\n  \\\"dish_type\\\": \\\"string or null\\\",\\n  \\\"dietary\\\": [\\\"array of tags\\\"],\\n  \\\"equipment\\\": [\\\"array of items\\\"],\\n  \\\"ingredients\\\": [{\\\"quantity\\\": \\\"string\\\", \\\"item\\\": \\\"string\\\", \\\"inferred\\\": boolean}],\\n  \\\"instructions\\\": [{\\\"step\\\": number, \\\"text\\\": \\\"string\\\", \\\"time\\\": \\\"string or null\\\"}],\\n  \\\"storage\\\": \\\"string or null\\\",\\n  \\\"variations\\\": [\\\"array of strings\\\"],\\n  \\\"nutritional_info\\\": \\\"string or null\\\",\\n  \\\"needs_review\\\": boolean,\\n  \\\"confidence_notes\\\": \\\"string\\\"\\n}\\n\\nExtract a recipe from this cooking video.\\n\\nVIDEO TITLE: {{ $json.title }}\\nCHANNEL: {{ $json.channel }}\\n\\nDESCRIPTION:\\n{{ $json.description }}\\n\\nTRANSCRIPT:\\n{{ $json.transcript }}\",\n  \"stream\": false,\n  \"format\": \"json\"\n}",
        "options": {
          "timeout": 120000
        }
      },
      "id": "ollama-extract",
      "name": "Ollama Extract Recipe",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1120, 200]
    },
    {
      "parameters": {
        "jsCode": "// Parse Ollama response and format as markdown\nconst ollamaResponse = $input.first().json;\nconst videoData = $('Parse JSON').first().json;\n\nlet recipe;\ntry {\n  recipe = JSON.parse(ollamaResponse.response);\n} catch (e) {\n  return [{ json: { error: 'Failed to parse recipe JSON', raw: ollamaResponse.response } }];\n}\n\n// Generate filename\nconst today = new Date().toISOString().split('T')[0];\nconst slug = (recipe.recipe_name || 'untitled-recipe')\n  .toLowerCase()\n  .replace(/[^a-z0-9]+/g, '-')\n  .replace(/^-|-$/g, '');\nconst filename = `${today}-${slug}.md`;\n\n// Helper functions\nconst quoteOrNull = (val) => val ? `\"${val}\"` : 'null';\nconst numOrNull = (val) => val !== null && val !== undefined ? val : 'null';\n\n// Format ingredients\nconst ingredients = (recipe.ingredients || []).map(ing => {\n  const inferred = ing.inferred ? ' *(inferred)*' : '';\n  return `- ${ing.quantity || ''} ${ing.item || ''}${inferred}`;\n}).join('\\n');\n\n// Format instructions\nconst instructions = (recipe.instructions || []).map(inst => {\n  const timeNote = inst.time ? ` (${inst.time})` : '';\n  return `${inst.step || ''}. ${inst.text || ''}${timeNote}`;\n}).join('\\n');\n\n// Format equipment list\nconst equipmentList = (recipe.equipment || []).map(e => `- ${e}`).join('\\n');\n\n// Format YAML arrays\nconst dietaryYaml = recipe.dietary && recipe.dietary.length > 0 \n  ? `[${recipe.dietary.join(', ')}]` \n  : '[]';\nconst equipmentYaml = recipe.equipment && recipe.equipment.length > 0\n  ? `[${recipe.equipment.map(e => `\"${e}\"`).join(', ')}]`\n  : '[]';\n\n// Format tags\nconst tags = [];\nif (recipe.cuisine) tags.push(`  - ${recipe.cuisine.toLowerCase().replace(/ /g, '-')}`);\nif (recipe.protein) tags.push(`  - ${recipe.protein.toLowerCase().replace(/ /g, '-')}`);\nif (recipe.dish_type) tags.push(`  - ${recipe.dish_type.toLowerCase().replace(/ /g, '-')}`);\nconst tagsYaml = tags.length > 0 ? tags.join('\\n') : '  - recipe';\n\n// Build notes section\nconst notesParts = [];\nif (recipe.storage) notesParts.push(`### Storage\\n${recipe.storage}`);\nif (recipe.variations && recipe.variations.length > 0) {\n  const vars = recipe.variations.map(v => `- ${v}`).join('\\n');\n  notesParts.push(`### Variations\\n${vars}`);\n}\nif (recipe.nutritional_info) notesParts.push(`### Nutritional Info\\n${recipe.nutritional_info}`);\nconst notesSection = notesParts.length > 0 \n  ? `\\n\\n## Notes\\n\\n${notesParts.join('\\n\\n')}\\n` \n  : '';\n\n// Build markdown\nconst markdown = `---\ntitle: \"${recipe.recipe_name || 'Untitled Recipe'}\"\nsource_url: \"${videoData.source_url || ''}\"\nsource_channel: \"${videoData.channel || 'Unknown'}\"\ndate_added: ${today}\nvideo_title: \"${videoData.title || 'Unknown Video'}\"\n\nprep_time: ${quoteOrNull(recipe.prep_time)}\ncook_time: ${quoteOrNull(recipe.cook_time)}\ntotal_time: ${quoteOrNull(recipe.total_time || recipe.cook_time || recipe.prep_time)}\nservings: ${numOrNull(recipe.servings)}\ndifficulty: ${quoteOrNull(recipe.difficulty)}\n\ncuisine: ${quoteOrNull(recipe.cuisine)}\nprotein: ${quoteOrNull(recipe.protein)}\ndish_type: ${quoteOrNull(recipe.dish_type)}\ndietary: ${dietaryYaml}\n\nequipment: ${equipmentYaml}\n\ntags:\n${tagsYaml}\n\nneeds_review: ${recipe.needs_review !== false ? 'true' : 'false'}\nconfidence_notes: \"${recipe.confidence_notes || ''}\"\n---\n\n# ${recipe.recipe_name || 'Untitled Recipe'}\n\n> ${recipe.description || ''}\n\n## Ingredients\n\n${ingredients}\n\n## Instructions\n\n${instructions}\n\n## Equipment\n\n${equipmentList}\n${notesSection}\n---\n*Extracted from [${videoData.title || 'Unknown Video'}](${videoData.source_url || ''}) on ${today}*\n`;\n\nreturn [{\n  json: {\n    filename,\n    markdown,\n    recipe_name: recipe.recipe_name,\n    source_url: videoData.source_url\n  }\n}];"
      },
      "id": "format-markdown",
      "name": "Format Markdown",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1340, 200]
    },
    {
      "parameters": {
        "operation": "write",
        "fileName": "=/Users/chaseeasterling/Library/Mobile Documents/iCloud~md~obsidian/Documents/KitchenOS/Recipes/{{ $json.filename }}",
        "dataPropertyName": "markdown",
        "options": {}
      },
      "id": "write-file",
      "name": "Write to Obsidian",
      "type": "n8n-nodes-base.readWriteFile",
      "typeVersion": 1,
      "position": [1560, 200]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify({ success: true, message: 'Recipe saved', filename: $json.filename, recipe: $json.recipe_name }) }}"
      },
      "id": "respond-success",
      "name": "Respond Success",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [1780, 200]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify({ success: false, error: 'Failed to fetch video data', details: $json.error }) }}"
      },
      "id": "respond-error",
      "name": "Respond Error",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [1120, 400]
    }
  ],
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "Fetch Transcript",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Transcript": {
      "main": [
        [
          {
            "node": "Parse JSON",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse JSON": {
      "main": [
        [
          {
            "node": "Check Success",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Success": {
      "main": [
        [
          {
            "node": "Ollama Extract Recipe",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Respond Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Ollama Extract Recipe": {
      "main": [
        [
          {
            "node": "Format Markdown",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Markdown": {
      "main": [
        [
          {
            "node": "Write to Obsidian",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Write to Obsidian": {
      "main": [
        [
          {
            "node": "Respond Success",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [{"name": "KitchenOS"}],
  "triggerCount": 0,
  "updatedAt": "2026-01-07T00:00:00.000Z",
  "versionId": "1"
}
